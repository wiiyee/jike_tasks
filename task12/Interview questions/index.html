<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>高级前端工程师面试题</title>
    <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.css">
    <style>
        body {
            width: 1000px;
            margin: 0 auto;
            font-size: 16px;
            color: #666;
            line-height: 2em;
            font-family: "Microsoft YaHei";
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-size: 18px;
            padding: 20px 0;
            color: #66cccc;
        }

        ul,
        li {
            list-style: none outside none;
        }
    </style>
</head>

<body>
<H1>
    <SPAN>HTML、CSS部分</SPAN>
</H1>
<P>
    <SPAN>1.Doctype作用? 严格模式与混杂模式-如何触发这两种模式，区分它们有何意义?</SPAN>
</P>
    <PRE><SPAN><CODE> （1）、&lt;!DOCTYPE&gt;
        声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。

        （2）、严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。

        （3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。

        （4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。
    </CODE></SPAN></PRE>
<P>
    <SPAN>2.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</SPAN>
</P>
    <PRE><SPAN><CODE>（1）CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，比如div默认display属性值为“block”，成为“块级”元素；span默认display属性值为“inline”，是“行内”元素。

        （2）行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p

        （3）知名的空元素： &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;鲜为人知的是： &lt;area&gt;
        &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt;
        &lt;source&gt;
        &lt;track&gt; &lt;wbr&gt;
    </CODE></SPAN></PRE>
<P>
    <SPAN>3.CSS的盒子模型？</SPAN>
</P>
    <PRE><SPAN><CODE>（1）两种， IE
        盒子模型、标准 W3C 盒子模型；IE 的content部分包含了 border 和 pading;

        （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border).
    </CODE></SPAN></PRE>
<P>
    <SPAN>4.link 和@import 的区别是?</SPAN>
</P>
    <PRE><SPAN><CODE>
        （1）、link属于XHTML标签，而@import是CSS提供的;

        （2）、页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;

        （3）、import只在IE5以上才能识别，而link是XHTML标签，无兼容问题;

        （4）、link方式的样式的权重 高于@import的权重.
    </CODE></SPAN></PRE>
<P>
    <SPAN>5.CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</SPAN>
</P>
    <PRE><SPAN><CODE> *
        1.id选择器（ # myid）
        2.类选择器（.myclassname）
        3.标签选择器（div, h1, p）
        4.相邻选择器（h1 + p）
        5.子选择器（ul &lt; li）
        6.后代选择器（li a）
        7.通配符选择器（ * ）
        8.属性选择器（a[rel = "external"]）
        9.伪类选择器（a: hover, li: nth - child）

        * 可继承： font-size font-family color, UL LI DL DD DT;

        * 不可继承 ：border padding margin width height ;

        * 优先级就近原则，样式定义最近者为准;

        * 载入样式以最后载入的定位为准;
    </CODE></SPAN></PRE>
<P>
    <SPAN>优先级为:</SPAN>
</P>
    <PRE><SPAN><CODE>
        !important &gt; id &gt; class &gt; tag

        important 比 内联优先级高
    </CODE></SPAN></PRE>
<P>
    <SPAN>CSS3新增伪类举例：</SPAN>
</P>
    <PRE><SPAN><CODE>
        p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
        p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
        p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
        p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
        p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。
        :enabled、:disabled 控制表单控件的禁用状态。
        :checked，单选框或复选框被选中。
    </CODE></SPAN></PRE>
<P>
    <SPAN>6.如何居中div,如何居中一个浮动元素?</SPAN>
</P>
<P>垂直居中常用方法：</P>
    <PRE><CODE class="hljs dts"><SPAN class=hljs-params>&lt;!-- html结构 --&gt;</SPAN>
        <SPAN class=hljs-params>&lt;body&gt;</SPAN>
        <SPAN class=hljs-params>&lt;div class="wrap"&gt;</SPAN>
        <SPAN class=hljs-params>&lt;div class="box"&gt;</SPAN><SPAN class=hljs-params>&lt;/div&gt;</SPAN>
        <SPAN class=hljs-params>&lt;/div&gt;</SPAN>
        <SPAN class=hljs-params>&lt;/body&gt;</SPAN>

        <SPAN class=hljs-comment>/* css样式 */</SPAN>

        <SPAN class=hljs-comment>/* (1) 模仿单行文字居中的方式 */</SPAN>
        .<SPAN class=hljs-class>wrap </SPAN>{
        <SPAN class=hljs-symbol>width:</SPAN> <SPAN class=hljs-number>200</SPAN>px;
        <SPAN class=hljs-symbol>height:</SPAN> <SPAN class=hljs-number>80</SPAN>px;
        line-height: <SPAN class=hljs-number>80</SPAN>px;
        }

        .<SPAN class=hljs-class>box </SPAN>{
        <SPAN class=hljs-symbol>display:</SPAN> inline-block;
        vertical-align:middle;
        }

        <SPAN class=hljs-comment>/* (2) 已知宽高，通过position:absolute; */</SPAN>
        .<SPAN class=hljs-class>wrap </SPAN>{
        <SPAN class=hljs-symbol>width:</SPAN> <SPAN class=hljs-number>200</SPAN>px;
        <SPAN class=hljs-symbol>height:</SPAN> <SPAN class=hljs-number>200</SPAN>px;
        <SPAN class=hljs-symbol>position:</SPAN> relative;
        }

        .<SPAN class=hljs-class>box </SPAN>{
        <SPAN class=hljs-symbol>width:</SPAN> <SPAN class=hljs-number>100</SPAN>px;
        <SPAN class=hljs-symbol>height:</SPAN> <SPAN class=hljs-number>80</SPAN>px;
        <SPAN class=hljs-symbol>position:</SPAN> absolute;
        <SPAN class=hljs-symbol>left:</SPAN> <SPAN class=hljs-number>50</SPAN>%;
        <SPAN class=hljs-symbol>top:</SPAN> <SPAN class=hljs-number>50</SPAN>%;
        <SPAN class=hljs-symbol>margin:</SPAN> <SPAN class=hljs-number>-50</SPAN>px <SPAN class=hljs-number>0</SPAN> <SPAN
                class=hljs-number>0</SPAN> <SPAN class=hljs-number>-40</SPAN>px;
        }

        <SPAN class=hljs-comment>/* (3) 未知宽高，通过css3属性 transfrom */</SPAN>
        .<SPAN class=hljs-class>wrap </SPAN>{
        <SPAN class=hljs-symbol>width:</SPAN> <SPAN class=hljs-number>200</SPAN>px;
        <SPAN class=hljs-symbol>height:</SPAN> <SPAN class=hljs-number>200</SPAN>px;
        <SPAN class=hljs-symbol>position:</SPAN> relative;
        }

        .<SPAN class=hljs-class>box </SPAN>{
        <SPAN class=hljs-symbol>position:</SPAN> absolute;
        <SPAN class=hljs-symbol>left:</SPAN> <SPAN class=hljs-number>50</SPAN>%;
        <SPAN class=hljs-symbol>top:</SPAN> <SPAN class=hljs-number>50</SPAN>%;
        -webkit-transform: translateX(<SPAN class=hljs-number>-50</SPAN>%) translateY(<SPAN class=hljs-number>-50</SPAN>%);
        <SPAN class=hljs-symbol>transform:</SPAN> translateX(<SPAN class=hljs-number>-50</SPAN>%) translateY(<SPAN
                class=hljs-number>-50</SPAN>%);
        }

        <SPAN class=hljs-comment>/* (4) 通过flex布局 */</SPAN>
        <SPAN class=hljs-params>&lt;!-- html结构 --&gt;</SPAN>
        <SPAN class=hljs-params>&lt;body&gt;</SPAN>
        <SPAN class=hljs-params>&lt;div class="wrap flexbox flexbox-center flexbox-middle"&gt;</SPAN>
        <SPAN class=hljs-params>&lt;div class="box"&gt;</SPAN><SPAN class=hljs-params>&lt;/div&gt;</SPAN>
        <SPAN class=hljs-params>&lt;/div&gt;</SPAN>
        <SPAN class=hljs-params>&lt;/body&gt;</SPAN>

        <SPAN class=hljs-comment>/* css样式 */</SPAN>

        .<SPAN class=hljs-class>flexbox </SPAN>{
        <SPAN class=hljs-symbol>display:</SPAN> -webkit-box;
        <SPAN class=hljs-symbol>display:</SPAN> -moz-box;
        <SPAN class=hljs-symbol>display:</SPAN> -ms-flexbox;
        <SPAN class=hljs-symbol>display:</SPAN> -webkit-flex;
        <SPAN class=hljs-symbol>display:</SPAN> flex;
        }

        <SPAN class=hljs-comment>/* 水平居中 */</SPAN>
        .flexbox-<SPAN class=hljs-class>center </SPAN>{
        -webkit-box-pack: center;
        -moz-box-pack: center;
        -ms-flex-pack: center;
        -webkit-justify-content: center;
        justify-content: center;
        }

        <SPAN class=hljs-comment>/* 垂直居中 */</SPAN>
        .flexbox-<SPAN class=hljs-class>middle </SPAN>{
        -webkit-box-align: center;
        -moz-box-align: center;
        -ms-flex-align: center;
        -webkit-align-items: center;
        align-items: center;
        }</CODE></PRE>
<P>
    <SPAN>7.浏览器的内核分别是什么?经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</SPAN>
</P>
    <PRE><SPAN><CODE> *
        IE浏览器的内核Trident、 Mozilla的Gecko、google的WebKit、Opera内核Presto；

        * png24为的图片在iE6浏览器上出现背景，解决方案是做成PNG8.

        * 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。

        * IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。

        浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;}

        这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)

        渐进识别的方式，从总体中逐渐排除局部。

        首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。
        接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。

        css
        .bb{
        background-color:#f1ee18;/*所有识别*/
        .background-color:#00deff\9; /*IE6、7、8识别*/
        +background-color:#a200ff;/*IE6、7识别*/
        _background-color:#1e0bd1;/*IE6识别*/

        }

        * IE下,可以使用获取常规属性的方法来获取自定义属性,
        也可以使用getAttribute()获取自定义属性;
        Firefox下,只能使用getAttribute()获取自定义属性.
        解决方法:统一通过getAttribute()获取自定义属性.

        * IE下,even对象有x,y属性,但是没有pageX,pageY属性;
        Firefox下,event对象有pageX,pageY属性,但是没有x,y属性.

        * （条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

        * Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.

        超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:
        L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}
    </CODE></SPAN></PRE>
<P>
    <SPAN>8.html5\CSS3有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</SPAN>
</P>
<UL>
    <LI>
        <P>
            <SPAN>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，地理定位等功能的增加。</SPAN>
        </P>
            <PRE><SPAN><CODE>* 绘画
                canvas 元素

                用于媒介回放的 video 和 audio 元素

                本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
                sessionStorage 的数据在浏览器关闭后自动删除

                语意化更好的内容元素，比如 article、footer、header、nav、section

                表单控件，calendar、date、time、email、url、search

                CSS3实现圆角，阴影，对文字加特效，增加了更多的CSS选择器 多背景 rgba

                新的技术webworker, websockt, Geolocation
            </CODE></SPAN></PRE>
    </LI>
    <LI>
        <P>
            <SPAN>移除的元素</SPAN>
        </P>
            <PRE><SPAN><CODE>纯表现的元素：basefont，big，center，font,
                s，strike，tt，u；

                对可用性产生负面影响的元素：frame，frameset，noframes；

                * 是IE8/IE7/IE6支持通过document.createElement方法产生的标签，
                可以利用这一特性让这些浏览器支持HTML5新标签，

                浏览器支持新标签后，还需要添加标签默认的样式：

                * 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架
                &lt;!--[if lt IE 9]&gt;
                &lt;script&gt; src="http://html5shim.googlecode.com/svn/trunk/html5.js"&lt;/script&gt;
                &lt;![endif]--&gt;
            </CODE></SPAN></PRE>
    </LI>
</UL>
<P>
    <SPAN>9.你怎么来实现页面设计图，你认为前端应该如何高质量完成工作? 一个满屏 品 字布局 如何设计?</SPAN>
</P>
    <PRE><SPAN><CODE>*
        首先划分成头部、body、脚部；。。。。。

        *
        实现效果图是最基本的工作，精确到2px；

        与设计师，产品经理的沟通和项目的参与

        做好的页面结构，页面重构和用户体验

        处理hack，兼容、写出优美的代码格式

        针对服务器的优化、拥抱 HTML5。
    </CODE></SPAN></PRE>
<P>
    <SPAN>10.常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？</SPAN>
</P>
    <PRE><SPAN><CODE> *
        使用率较高的框架有jQuery、YUI、Prototype、Dojo、Ext.js、Mootools等。尤其是jQuery，超过91%。

        轻量级框架有Modernizr、underscore.js、backbone.js、Raphael.js等。
        （理解这些框架的功能、性能、设计原理）

        * Sublime Text 、Eclipse、Notepad、Firebug、HttpWatch、Yslow。

        * 城市选择插件，汽车型号选择插件、幻灯片插件。弹出层。（写过开源程序，加载器，js引擎更好）
    </CODE></SPAN></PRE>
<OL>
    <LI>
        <P>
            <SPAN>JavaScript原型，原型链 ? 有什么特点？</SPAN>
        </P>
            <PRE><SPAN><CODE>*
                原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。
                * 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。

                * JavaScript的数据对象有那些属性值？

                　　writable：这个属性的值是否可以改。

                　　configurable：这个属性的配置是否可以删除，修改。

                　　enumerable：这个属性是否能在for…in循环中遍历出来或在Object.keys中列举出来。

                　　value：属性值。

                * 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话，就会查找他的Prototype对象是否有这个属性。

                function clone(proto) {

                　　function Dummy() { }

                　　Dummy.prototype = proto;

                　　Dummy.prototype.constructor = Dummy;

                　　return new Dummy(); //等价于Object.create(Person);

                }

                function object(old) {
                &nbsp; &nbsp;&nbsp;function F() {};
                &nbsp; &nbsp;&nbsp;F.prototype = old;
                &nbsp; &nbsp;&nbsp;return new F();
                }
                var newObj = object(oldObject);
            </CODE></SPAN></PRE>
    </LI>
</OL>
<P>
    <SPAN>12.列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？</SPAN>
</P>
    <PRE><SPAN><CODE> 1. block
        象块类型元素一样显示。
        none 缺省值。向行内元素类型一样显示。
        inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。
        list-item 象块类型元素一样显示，并添加样式列表标记。

        2.
        *absolute
        生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。

        *fixed （老IE不支持）
        生成绝对定位的元素，相对于浏览器窗口进行定位。

        *relative
        生成相对定位的元素，相对于其正常位置进行定位。

        * static 默认值。没有定位，元素出现在正常的流中
        *（忽略 top, bottom, left, right z-index 声明）。

        * inherit 规定从父元素继承 position 属性的值。
    </CODE></SPAN></PRE>
<P>
    <SPAN>13.页面重构怎么操作？</SPAN>
</P>
    <PRE><SPAN><CODE>编写 CSS、让页面结构更合理化，提升用户体验，实现良好的页面效果和提升性能。
    </CODE></SPAN></PRE>
<P>
    <SPAN>14.语义化的理解？</SPAN>
</P>
    <PRE><SPAN><CODE>html语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；
        在没有样式CCS情况下也以一种文档格式显示，并且是容易阅读的。
        搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。
        使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。
    </CODE></SPAN></PRE>
<p>15.HTML5的离线储存有几种方式？</p>
<p>localStorage长期存储数据，浏览器关闭后数据不丢失；sessionStorage 数据在浏览器关闭后自动删除。</p>
<P>
    <SPAN>请描述一下 cookies，sessionStorage和localStorage的区别？</SPAN>
</P>
cookie在浏览器和服务器间来回传递。sessionStorage和localStorage不会sessionStorage和localStorage的存储空间更大；sessionStorage和 localStorage有更多丰富易用的接口；sessionStorage和localStorage各自独立的存储空间
<P>
    <SPAN>16.为什么要初始化CSS样式。</SPAN>
</P>
<UL>
    <LI>
        <P>
            <SPAN>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</SPAN>
        </P>
    </LI>
    <LI>
        <P>
            <SPAN>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</SPAN>
        </P>
    </LI>
</UL>
<P>
    <SPAN>*最简单的初始化方法就是： * {padding: 0; margin: 0;} （不建议）</SPAN>
</P>
    <PRE><SPAN><CODE> 淘宝的样式初始化：
        body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend,
        button,
        input, textarea, th, td { margin:0; padding:0; }
        body, button, input, select, textarea { font:12px/1.5tahoma, arial, \5b8b\4f53; }
        h1, h2, h3, h4, h5, h6{ font-size:100%; }
        address, cite, dfn, em, var { font-style:normal; }
        code, kbd, pre, samp { font-family:couriernew, courier, monospace; }
        small{ font-size:12px; }
        ul, ol { list-style:none; }
        a { text-decoration:none; }
        a:hover { text-decoration:underline; }
        sup { vertical-align:text-top; }
        sub{ vertical-align:text-bottom; }
        legend { color:#000; }
        fieldset, img { border:0; }
        button, input, select, textarea { font-size:100%; }
        table { border-collapse:collapse; border-spacing:0; }
    </CODE></SPAN></PRE>
<P>
    <SPAN>17.(写)描述一段语义的html代码吧。</SPAN>
</P>
    <PRE><SPAN><CODE>
        （HTML5中新增加的很多标签（如：&lt;article&gt;、&lt;nav&gt;、&lt;header&gt;和&lt;footer&gt;等）
        就是基于语义化设计原则）

        &lt; div id="header"&gt;
        &lt; h1&gt;标题&lt; /h1&gt;
        &lt; h2&gt;专注Web前端技术&lt; /h2&gt;
        &lt; /div&gt;
    </CODE></SPAN></PRE>
<UL>
    <LI>
        <P>
            <SPAN>语义 HTML 具有以下特性：</SPAN>
        </P>
            <PRE><SPAN
            ><CODE
            >文字包裹在元素中，用以反映内容。例如：
                段落包含在 &lt;p&gt; 元素中。
                顺序表包含在&lt;ol&gt;元素中。
                从其他来源引用的大型文字块包含在&lt;blockquote&gt;元素中。
                HTML 元素不能用作语义用途以外的其他目的。例如：
                &lt;h1&gt;包含标题，但并非用于放大文本。
                &lt;blockquote&gt;包含大段引述，但并非用于文本缩进。
                空白段落元素 ( &lt;p&gt;&lt;/p&gt; ) 并非用于跳行。
                文本并不直接包含任何样式信息。例如：
                不使用 &lt;font&gt; 或 &lt;center&gt; 等格式标记。
                类或 ID 中不引用颜色或位置。
            </CODE></SPAN></PRE>
    </LI>
</UL>
<P>
    <SPAN>18.absolute的containing block计算方式跟正常流有什么不同？</SPAN>
</P>
<P>
    <SPAN>19.position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？</SPAN>
</P>
<P>
    <SPAN>20.对BFC规范的理解？（W3C CSS 2.1 规范中的一个概念,它决定了元素如何对其内容进行定位,以及与其他元素的关 系和相互作用。）</SPAN>
</P>
<P>
    <SPAN>21.iframe有那些缺点？</SPAN>
</P>
    <PRE><SPAN><CODE>
        *iframe会阻塞主页面的Onload事件；
        *iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。
        使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript
        动态给iframe添加src属性值，这样可以可以绕开以上两个问题。
    </CODE></SPAN></PRE>
<P>
    <SPAN>22.css定义的权重</SPAN>
</P>
    <PRE><SPAN><CODE>以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值：

        /*权重为1*/
        div{
        }
        /*权重为10*/
        .class1{
        }
        /*权重为100*/
        #id1{
        }
        /*权重为100+1=101*/
        #id1 div{
        }
        /*权重为10+1=11*/
        .class1 div{
        }
        /*权重为10+10+1=21*/
        .class1 .class2 div{
        }

        如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现
    </CODE></SPAN></PRE>
<P>
    <SPAN>23.eval是做什么的？</SPAN>
</P>
    <PRE><SPAN><CODE>它的功能是把对应的字符串解析成JS代码并运行；
        避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。
    </CODE></SPAN></PRE>
<P>
    <SPAN>23.写一个通用的事件侦听器函数</SPAN>
</P>
    <PRE><SPAN><CODE>`//
        event(事件)工具集，来源：https://github.com/markyun
        markyun.Event = {
        // 页面加载完成后
        readyEvent : function(fn) {
        if (fn==null) {
        fn=document;
        }
        var oldonload = window.onload;
        if (typeof window.onload != 'function') {
        window.onload = fn;
        } else {
        window.onload = function() {
        oldonload();
        fn();
        };
        }
        },
        // 视能力分别使用dom0||dom2||IE方式 来绑定事件
        // 参数： 操作的元素,事件名称 ,事件处理程序
        addEvent : function(element, type, handler) {
        if (element.addEventListener) {
        //事件类型、需要执行的函数、是否捕捉
        element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
        element.attachEvent('on' + type, function() {
        handler.call(element);
        });
        } else {
        element['on' + type] = handler;
        }
        },
        // 移除事件
        removeEvent : function(element, type, handler) {
        if (element.removeEnentListener) {
        element.removeEnentListener(type, handler, false);
        } else if (element.datachEvent) {
        element.detachEvent('on' + type, handler);
        } else {
        element['on' + type] = null;
        }
        },
        // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
        stopPropagation : function(ev) {
        if (ev.stopPropagation) {
        ev.stopPropagation();
        } else {
        ev.cancelBubble = true;
        }
        },
        // 取消事件的默认行为
        preventDefault : function(event) {
        if (event.preventDefault) {
        event.preventDefault();
        } else {
        event.returnValue = false;
        }
        },
        // 获取事件目标
        getTarget : function(event) {
        return event.target || event.srcElement;
        },
        // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
        getEvent : function(e) {
        var ev = e || window.event;
        if (!ev) {
        var c = this.getEvent.caller;
        while (c) {
        ev = c.arguments[0];
        if (ev &amp;&amp; Event == ev.constructor) {
        break;
        }
        c = c.caller;
        }
        }
        return ev;
        }
        };
    </CODE></SPAN></PRE>
<P>
    <SPAN>24.99%的网站都需要被重构是那本书上写的？</SPAN>
</P>
    <PRE><SPAN><CODE>*
        网站重构：应用web标准进行设计（第2版）
    </CODE></SPAN></PRE>
<P>
    <SPAN>25.什么叫优雅降级和渐进增强？</SPAN>
</P>
    <PRE><SPAN><CODE>优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.

        渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。
    </CODE></SPAN></PRE>
<P>
    <SPAN>26.Node.js的适用场景</SPAN>
</P>
    <PRE><SPAN><CODE>高并发、聊天、实时消息推送
    </CODE></SPAN></PRE>
<P>
    <SPAN>27.WEB应用从服务器主动推送Data到客户端有那些方式？</SPAN>
</P>
    <PRE><SPAN><CODE> html5
        websoket
        WebSocket通过Flash
        XHR长时间连接
        XHR Multipart Streaming
        不可见的Iframe
        &lt;script&gt;标签的长时间连接(可跨域)
    </CODE></SPAN></PRE>
<HR>
<H1>
    <SPAN> JavaScript部分</SPAN></H1>
    <PRE><SPAN><CODE>要点：
        数据类型、面向对象、继承、闭包、插件、作用域、跨域、原型链、模块化、自定义事件、异步装载回调、模板引擎、Nodejs等。
    </CODE></SPAN></PRE>
<HR>
    <PRE><SPAN><CODE>js的几种数据类型：number,string,boolean,object,undefined

        js的常见内置对象类：Date,Array,Math、Number、Boolean、String、Array、RegExp、Function...
    </CODE></SPAN></PRE>
<UL>
    <LI>
        <P>
            <SPAN>通常可以做一些小练习来判断TA的水平，js 虽然很灵活，但是具体的代码和实现方式能体现出一个人的全局观，随着代码规模的增长，复杂度增加，如何合理划分模块实现功能和接口的能力比较重要。（下面例题）</SPAN>
        </P>
            <PRE><SPAN><CODE>["1",
                "2", "3"].map(parseInt)

                [typeof null, null instanceof Object]

                [ [3,2,1].reduce(Math.pow), [].reduce(Math.pow)] ]

                var val = 'smtg';
                console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');
            </CODE></SPAN></PRE>
    </LI>
</UL>
<P>
    <SPAN>1.创建一个对象</SPAN>
</P>
    <PRE><SPAN><CODE> function
        Person(name, age) {
        this.name = name;
        this.age = age;
        this.sing = function() { alert(this.name) }
        }
    </CODE></SPAN></PRE>
<P>
    <SPAN>2.谈谈This对象的理解。</SPAN>
</P>
    <PRE><SPAN><CODE>this是js的一个关键字，随着函数使用场合不同，this的值会发生变化。

        但是总有一个原则，那就是this指的是调用函数的那个对象。

        this一般情况下：是全局对象Global。 作为方法调用，那么this就是指这个对象
    </CODE></SPAN></PRE>
<P>
    <SPAN>3.事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</SPAN>
</P>
    <PRE><SPAN><CODE> 1.
        我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。
        2. 事件处理机制：IE是事件冒泡、火狐是 事件捕获；
        3. ev.stopPropagation();
    </CODE></SPAN></PRE>
<P>
    <SPAN>4.什么是闭包（closure），为什么要用？</SPAN>
</P>
<UL>
    <LI>
        <P>
            <SPAN>待完善</SPAN>
        </P>
    </LI>
    <LI>
        <P>
            <SPAN>执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在.使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源，因为say667()的内部函数的执行需要依赖say667()中的变量。这是对闭包作用的非常直白的描述.</SPAN>
        </P>
            <PRE><SPAN><CODE>
                function say667() {
                // Local variable that ends up within closure
                var num = 666;
                var sayAlert = function() { alert(num); }
                num++;
                return sayAlert;
                }

                var sayAlert = say667();
                sayAlert()//执行结果应该弹出的667
            </CODE></SPAN></PRE>
    </LI>
</UL>
<P>
    <SPAN>5.如何判断一个对象是否属于某个类？</SPAN>
</P>
<P>
    <SPAN>使用instanceof （待完善）</SPAN>
</P>
    <PRE><SPAN><CODE> if(a
        instanceof Person){
        alert('yes');
        }
    </CODE></SPAN></PRE>
<P>
    <SPAN>6.new操作符具体干了什么呢?</SPAN>
</P>
    <PRE><SPAN><CODE>
        1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
        2、属性和方法被加入到 this 引用的对象中。
        3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。

        var obj = {};
        obj.__proto__ = Base.prototype;
        Base.call(obj);
    </CODE></SPAN></PRE>
<P>
    <SPAN>7.JSON 的了解</SPAN>
</P>
    <PRE><SPAN><CODE>JSON(JavaScript
        Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小
        {'age':'12', 'name':'back'}
    </CODE></SPAN></PRE>
<P>
    <SPAN>8.js延迟加载的方式有哪些</SPAN>
</P>
<UL>
    <LI>
        <SPAN>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</SPAN>
    </LI>
</UL>
<P>
    <SPAN>9.ajax 是什么?ajax 的交互模型?同步和异步的区别?如何解决跨域问题?</SPAN>
</P>
<UL>
    <LI>
        <P>
            <SPAN>待完善</SPAN>
        </P>
            <PRE><SPAN><CODE> 1.
                通过异步模式，提升了用户体验

                2. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用

                3. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。

                2. Ajax的最大的特点是什么。

                Ajax可以实现动态不刷新（局部刷新）
                readyState属性 状态 有5个可取值： 0=未初始化 ，1=正在加载 2=以加载，3=交互中，4=完成
            </CODE></SPAN></PRE>
    </LI>
    <LI>
        <P>
            <SPAN>ajax的缺点</SPAN>
        </P>
            <PRE><SPAN><CODE>
                1、ajax不支持浏览器back按钮。

                2、安全问题 AJAX暴露了与服务器交互的细节。

                3、对搜索引擎的支持比较弱。

                4、破坏了程序的异常机制。

                5、不容易调试。
            </CODE></SPAN></PRE>
    </LI>
    <LI>
        <SPAN>跨域： jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面</SPAN>
    </LI>
    <li>
        <span>ajax请求的时候get 和post方式的区别？</span>
        <p>1、get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到； post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程；</p>
        <p>
            2、Get请求有如下特性：它会将数据添加到URL中，通过这种方式传递到服务器，通常利用一个问号？代表URL地址的结尾与数据参数的开端，后面的参数每一个数据参数以“名称=值”的形式出现，参数与参数之间利用一个连接符&来区分。 Post请求有如下特性：数据是放在HTTP主体中的，其组织方式不只一种，有&连接方式，也有分割符方式，可隐藏参数，传递大批数据，比较方便。
        </p>
        <p> 3、get传送的数据量较小，不能大于2KB； post传送的数据量较大，一般被默认为不受限制。但理论上，因服务器的不同而异.
        </p>
        <p> 4、get安全性非常低，post安全性较高；</p>
    </li>
</UL>
<P>
    <SPAN>10.模块化怎么做？</SPAN>
</P>
<P>
    <SPAN><A href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">立即执行函数</A>,不暴露私有成员</SPAN>
</P>
    <PRE><SPAN><CODE>var
        module1 = (function(){
        　　　　var _count = 0;
        　　　　var m1 = function(){
        　　　　　　//...
        　　　　};
        　　　　var m2 = function(){
        　　　　　　//...
        　　　　};
        　　　　return {
        　　　　　　m1 : m1,
        　　　　　　m2 : m2
        　　　　};
        　　})();
    </CODE></SPAN></PRE>
<P>
    <SPAN>11.对Node的优点和缺点提出了自己的看法：</SPAN>
</P>
    <PRE><SPAN><CODE>
        *（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，
        因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。
        此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，
        因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。

        *（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，
        而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。
    </CODE></SPAN></PRE>
<P>
    <SPAN>12.异步加载的方式</SPAN>
</P>
    <PRE><SPAN><CODE> (1)
        defer，只支持IE

        (2) async：

        (3) 创建script，插入到DOM中，加载完毕后callBack

        documen.write和 innerHTML的区别

        document.write只能重绘整个页面

        innerHTML可以重绘页面的一部分
    </CODE></SPAN></PRE>
<P>
    <SPAN>13.告诉我答案是多少？</SPAN>
</P>
    <PRE><SPAN><CODE>
        (function(x){
        delete x;
        alert(x);
        })(1+5);

        函数参数无法delete删除，delete只能删除通过for in访问的属性。
        当然，删除失败也不会报错，所以代码运行会弹出“1”。
    </CODE></SPAN></PRE>
<P>
    <SPAN>14.JS中的call()和apply()方法的区别？</SPAN>
</P>
<P>
    <SPAN>例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4);</SPAN>
</P>
<P>
    <SPAN>注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。</SPAN>
</P>
    <PRE><SPAN><CODE>function
        add(a,b)
        {
        alert(a+b);
        }

        function sub(a,b)
        {
        alert(a-b);
        }

        add.call(sub,3,1);
    </CODE></SPAN></PRE>
<P>
    <SPAN>15.Jquery与jQuery UI 有啥区别？</SPAN>
</P>
    <PRE><SPAN><CODE>
        *jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。

        *jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。
        提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等
    </CODE></SPAN></PRE>
<P>
    <SPAN>16.jquery 中如何将数组转化为json字符串，然后再转化回来？</SPAN>
</P>
<P>
    <SPAN>jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：</SPAN>
</P>
    <PRE><SPAN><CODE>
        $.fn.stringifyArray = function(array) {
        return JSON.stringify(array)
        }

        $.fn.parseArray = function(array) {
        return JSON.parse(array)
        }

        然后调用：
        $("").stringifyArray(array)
    </CODE></SPAN></PRE>
<P>
    <SPAN>17.JavaScript中的作用域与变量声明提升？</SPAN>
</P>
<p>
    一个变量的作用域表示这个变量存在的上下文。它指定了你可以访问哪些变量以及你是否有权限访问某个变量。” 变量作用域分为局部作用域和全局作用域。 局部变量（处于函数级别的作用域） 不像其他对面对象的编程语言（比方说C++，Java等等），javascript没有块级作用域（被花括号包围的）；当是，javascript有拥有函数级别的作用域，也就是说，在一个函数内定义的变量只能在函数内部访问或者这个函数内部的函数访问（闭包除外）
</p>
<H1>
    <SPAN>其他部分</SPAN></H1>
<H3>
    <SPAN> （HTTP、正则、优化、重构、响应式、移动端、团队协作、SEO、UED、职业生涯）</SPAN>
</H3>
<HR>
    <PRE><SPAN><CODE>
        *基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。

        *频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。
        比如：var str=$("a").attr("href");

        *for (var i = size; i &lt; arr.length; i++) {}
        for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快：
        for (var i = size, length = arr.length; i &lt; length; i++) {}
    </CODE></SPAN></PRE>
<UL>
    <LI>
        <P>
            <SPAN>前端开发的优化问题（看雅虎14条性能优化原则）。</SPAN>
        </P>
            <PRE><SPAN><CODE> （1）
                减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。

                （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

                （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。

                （4） 当需要设置的样式很多时设置className而不是直接操作style。

                （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。

                （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。

                （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。

                （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
            </CODE></SPAN></PRE>
    </LI>
</UL>
<P>
    <SPAN>http状态码有那些？分别代表是什么意思？</SPAN>
</P>
    <PRE><SPAN><CODE> 100-199
        用于指定客户端应相应的某些动作。
        200-299 用于表示请求成功。
        300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。
        400-499 用于指出客户端的错误。400 1、语义有误，当前请求无法被服务器理解。401 当前请求需要用户验证 403 服务器已经理解请求，但是拒绝执行它。
        500-599 用于支持服务器错误。 503 – 服务不可用
    </CODE></SPAN></PRE>
<P>
    <SPAN>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</SPAN>
</P>
<P>
    <SPAN>你所知道的页面性能优化方法有那些？</SPAN>
</P>
<P>
    <SPAN>除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？</SPAN>
</P>
<P>
    <SPAN>AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？</SPAN>
</P>
<P>
    <SPAN>18.谈谈你认为怎样做能是项目做的更好？</SPAN>
</P>
<P>
    <SPAN>19.你对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？</SPAN>
</P>
<P>
    <SPAN>20.加班的看法</SPAN>
</P>
    <PRE><SPAN
    ><CODE
    >加班就像借钱，原则应当是------救急不救穷
    </CODE></SPAN></PRE>
<P>
    <SPAN>21.平时如何管理你的项目，如何设计突发大规模并发架构？</SPAN>
</P>
    <PRE><SPAN><CODE>先期团队必须确定好全局样式（globe.css），编码模式(utf-8)
        等

        编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；

        标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；

        页面进行标注（例如 页面 模块 开始和结束）；

        CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）

        JS 分文件夹存放 命民以该JS 功能为准英文翻译；

        图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理
    </CODE></SPAN></PRE>
<OL>
    <LI>
        <P>
            <SPAN>那些操作会造成内存泄漏？</SPAN>
        </P>
            <PRE><SPAN><CODE>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。
                垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

                setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
                闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）
            </CODE></SPAN></PRE>
    </LI>
</OL>
<P>
    <SPAN>23.你说你热爱前端，那么应该WEB行业的发展很关注吧？ 说说最近最流行的一些东西吧？</SPAN>
</P>
    <PRE><SPAN><CODE>Node.js、Mongodb、npm、MVVM、react、grunt、yeoman、webpack、bower、vuejs、angularJs、AMD/CMD
    </CODE></SPAN></PRE>
<P>
    <SPAN>24.你有了解我们公司吗？说说你的认识？</SPAN>
</P>
<P>
    <SPAN>25.移动端（比如：Android IOS）怎么做好用户体验?</SPAN>
</P>
<HR>
    <PRE><SPAN><CODE> 1、DOM结构
        —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。

        2、DOM操作 ——如何添加、移除、移动、复制、创建和查找节点等。

        3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。

        4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。

        5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。

        6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型

        7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们

        8、浮动元素——怎么使用它们、它们有什么问题以及怎么解决这些问题。

        9、HTML与XHTML——二者有什么区别，你觉得应该使用哪一个并说出理由。

        10、JSON —— 作用、用途、设计结构。</CODE></SPAN></PRE>
</div>
<br>
<br>
</body>

</html>
